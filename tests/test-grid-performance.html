<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Rendering Performance Benchmark</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        canvas {
            border: 1px solid #444;
            margin: 10px;
        }
        .results {
            margin: 20px 0;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 5px;
        }
        .metric {
            margin: 5px 0;
        }
        .better {
            color: #4ade80;
            font-weight: bold;
        }
        .section {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>Grid Rendering Performance Benchmark</h1>
    <p>This benchmark compares the OLD method (redrawing grid every frame) vs NEW method (cached grid)</p>

    <div class="section">
        <h2>Old Method (Redraw Grid Every Frame)</h2>
        <canvas id="old-canvas" width="300" height="600"></canvas>
        <div class="results" id="old-results">Running benchmark...</div>
    </div>

    <div class="section">
        <h2>New Method (Cached Grid)</h2>
        <canvas id="new-canvas" width="300" height="600"></canvas>
        <div class="results" id="new-results">Running benchmark...</div>
    </div>

    <div class="results" id="comparison">
        <h3>Performance Comparison</h3>
        <div id="comparison-data">Will be calculated after benchmarks complete...</div>
    </div>

    <script>
        const COLS = 10, ROWS = 20, BLOCK_SIZE = 30;
        const FRAMES = 600; // Test for 10 seconds at 60fps

        // OLD METHOD: Redraw grid every frame
        function benchmarkOldMethod() {
            return new Promise((resolve) => {
                const canvas = document.getElementById('old-canvas');
                const ctx = canvas.getContext('2d');
                let frameCount = 0;
                const startTime = performance.now();
                const frameTimes = [];

                function drawFrame() {
                    const frameStart = performance.now();

                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // OLD METHOD: Draw grid lines every frame
                    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                    ctx.lineWidth = 1;

                    // Draw vertical lines
                    for (let x = 0; x <= COLS; x++) {
                        ctx.beginPath();
                        ctx.moveTo(x * BLOCK_SIZE, 0);
                        ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                        ctx.stroke();
                    }

                    // Draw horizontal lines
                    for (let y = 0; y <= ROWS; y++) {
                        ctx.beginPath();
                        ctx.moveTo(0, y * BLOCK_SIZE);
                        ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                        ctx.stroke();
                    }

                    const frameEnd = performance.now();
                    frameTimes.push(frameEnd - frameStart);
                    frameCount++;

                    if (frameCount < FRAMES) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        const endTime = performance.now();
                        const totalTime = endTime - startTime;
                        const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
                        const maxFrameTime = Math.max(...frameTimes);
                        const minFrameTime = Math.min(...frameTimes);

                        resolve({
                            totalTime,
                            avgFrameTime,
                            maxFrameTime,
                            minFrameTime,
                            fps: (FRAMES / (totalTime / 1000)).toFixed(2)
                        });
                    }
                }

                requestAnimationFrame(drawFrame);
            });
        }

        // NEW METHOD: Use cached grid
        function benchmarkNewMethod() {
            return new Promise((resolve) => {
                const canvas = document.getElementById('new-canvas');
                const ctx = canvas.getContext('2d');

                // Create grid cache
                const gridCache = document.createElement('canvas');
                gridCache.width = canvas.width;
                gridCache.height = canvas.height;
                const gridCtx = gridCache.getContext('2d');

                // Draw grid once onto cache
                gridCtx.strokeStyle = 'rgba(255,255,255,0.05)';
                gridCtx.lineWidth = 1;

                for (let x = 0; x <= COLS; x++) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(x * BLOCK_SIZE, 0);
                    gridCtx.lineTo(x * BLOCK_SIZE, canvas.height);
                    gridCtx.stroke();
                }

                for (let y = 0; y <= ROWS; y++) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, y * BLOCK_SIZE);
                    gridCtx.lineTo(canvas.width, y * BLOCK_SIZE);
                    gridCtx.stroke();
                }

                let frameCount = 0;
                const startTime = performance.now();
                const frameTimes = [];

                function drawFrame() {
                    const frameStart = performance.now();

                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // NEW METHOD: Just draw the cached grid
                    ctx.drawImage(gridCache, 0, 0);

                    const frameEnd = performance.now();
                    frameTimes.push(frameEnd - frameStart);
                    frameCount++;

                    if (frameCount < FRAMES) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        const endTime = performance.now();
                        const totalTime = endTime - startTime;
                        const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
                        const maxFrameTime = Math.max(...frameTimes);
                        const minFrameTime = Math.min(...frameTimes);

                        resolve({
                            totalTime,
                            avgFrameTime,
                            maxFrameTime,
                            minFrameTime,
                            fps: (FRAMES / (totalTime / 1000)).toFixed(2)
                        });
                    }
                }

                requestAnimationFrame(drawFrame);
            });
        }

        function displayResults(elementId, results, label) {
            const element = document.getElementById(elementId);
            element.innerHTML = `
                <h3>${label}</h3>
                <div class="metric">Total Time: ${results.totalTime.toFixed(2)}ms</div>
                <div class="metric">Average Frame Time: ${results.avgFrameTime.toFixed(3)}ms</div>
                <div class="metric">Min Frame Time: ${results.minFrameTime.toFixed(3)}ms</div>
                <div class="metric">Max Frame Time: ${results.maxFrameTime.toFixed(3)}ms</div>
                <div class="metric">Effective FPS: ${results.fps}</div>
            `;
        }

        // Run benchmarks sequentially
        async function runBenchmarks() {
            console.log('Starting OLD method benchmark...');
            const oldResults = await benchmarkOldMethod();
            displayResults('old-results', oldResults, 'Old Method Results');

            console.log('Starting NEW method benchmark...');
            const newResults = await benchmarkNewMethod();
            displayResults('new-results', newResults, 'New Method Results');

            // Calculate improvement
            const improvement = ((oldResults.avgFrameTime - newResults.avgFrameTime) / oldResults.avgFrameTime * 100).toFixed(2);
            const speedup = (oldResults.avgFrameTime / newResults.avgFrameTime).toFixed(2);

            const comparisonEl = document.getElementById('comparison-data');
            comparisonEl.innerHTML = `
                <div class="metric better">Frame Time Improvement: ${improvement}% faster</div>
                <div class="metric better">Speedup: ${speedup}x</div>
                <div class="metric">Old avg frame time: ${oldResults.avgFrameTime.toFixed(3)}ms</div>
                <div class="metric">New avg frame time: ${newResults.avgFrameTime.toFixed(3)}ms</div>
                <div class="metric">Time saved per frame: ${(oldResults.avgFrameTime - newResults.avgFrameTime).toFixed(3)}ms</div>
                <div class="metric">Canvas API calls reduced: 88 â†’ 1 per frame</div>
            `;
        }

        // Start benchmarks when page loads
        runBenchmarks();
    </script>
</body>
</html>
